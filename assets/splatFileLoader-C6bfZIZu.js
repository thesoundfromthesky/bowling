import{f as z,M as q,d as L,g as N,h as D,P as F,A as H,L as Z,b as $,a as J,R as K}from"./index-UsGQmXg2.js";var E;(function(S){S[S.Splat=0]="Splat",S[S.PointCloud=1]="PointCloud",S[S.Mesh=2]="Mesh",S[S.Reject=3]="Reject"})(E||(E={}));class M{constructor(a=M._DefaultLoadingOptions){this.name=z.name,this._assetContainer=null,this.extensions=z.extensions,this._loadingOptions=a}createPlugin(a){return new M(a[z.name])}async importMeshAsync(a,r,e,c,n,f){return this._parse(a,r,e,c).then(w=>({meshes:w,particleSystems:[],skeletons:[],animationGroups:[],transformNodes:[],geometries:[],lights:[],spriteManagers:[]}))}static _BuildPointCloud(a,r){if(!r.byteLength)return!1;const e=new Uint8Array(r),c=new Float32Array(r),n=3*4+3*4+4+4,f=e.length/n,w=function(C,l){const s=c[8*l+0],o=c[8*l+1],p=c[8*l+2];C.position=new $(s,o,p);const x=e[n*l+24+0]/255,g=e[n*l+24+1]/255,i=e[n*l+24+2]/255;C.color=new J(x,g,i,1)};return a.addPoints(f,w),!0}static _BuildMesh(a,r){const e=new q("PLYMesh",a),c=new Uint8Array(r.data),n=new Float32Array(r.data),f=3*4+3*4+4+4,w=c.length/f,C=[],l=new L;for(let s=0;s<w;s++){const o=n[8*s+0],p=n[8*s+1],x=n[8*s+2];C.push(o,p,x)}if(r.hasVertexColors){const s=new Float32Array(w*4);for(let o=0;o<w;o++){const p=c[f*o+24+0]/255,x=c[f*o+24+1]/255,g=c[f*o+24+2]/255;s[o*4+0]=p,s[o*4+1]=x,s[o*4+2]=g,s[o*4+3]=1}l.colors=s}return l.positions=C,l.indices=r.faces,l.applyToMesh(e),e}_parseSPZ(a,r){const e=new Uint8Array(a),c=new Uint32Array(a),n=c[2],f=e[12],w=e[13];if(e[15]||c[0]!=1347635022||c[1]!=2)return new Promise(t=>{t({mode:3,data:s,hasVertexColors:!1})});const l=3*4+3*4+4+4,s=new ArrayBuffer(l*n),o=1/(1<<w),p=new Int32Array(1),x=new Uint8Array(p.buffer),g=function(t,h){return x[0]=t[h+0],x[1]=t[h+1],x[2]=t[h+2],x[3]=t[h+2]&128?255:0,p[0]*o};let i=16;const k=new Float32Array(s),U=new Float32Array(s),B=new Uint8ClampedArray(s),v=new Uint8ClampedArray(s);let u=1,d=0;this._loadingOptions.flipY||(u=-1,d=255);for(let t=0;t<n;t++)k[t*8+0]=g(e,i+0),k[t*8+1]=u*g(e,i+3),k[t*8+2]=u*g(e,i+6),i+=9;const V=.282;for(let t=0;t<n;t++){for(let h=0;h<3;h++){const A=(e[i+n+t*3+h]-127.5)/(.15*255);B[t*32+24+h]=N.Clamp((.5+V*A)*255,0,255)}B[t*32+24+3]=e[i+t]}i+=n*4;for(let t=0;t<n;t++)U[t*8+3+0]=Math.exp(e[i+0]/16-10),U[t*8+3+1]=Math.exp(e[i+1]/16-10),U[t*8+3+2]=Math.exp(e[i+2]/16-10),i+=3;for(let t=0;t<n;t++){const h=e[i+0],b=e[i+1]*u+d,A=e[i+2]*u+d,P=h/127.5-1,O=b/127.5-1,I=A/127.5-1;v[t*32+28+1]=h,v[t*32+28+2]=b,v[t*32+28+3]=A;const m=1-(P*P+O*O+I*I);v[t*32+28+0]=127.5+Math.sqrt(m<0?0:m)*127.5,i+=3}if(f){const h=((f+1)*(f+1)-1)*3,b=Math.ceil(h/16);let A=i;const P=[],I=r.getEngine().getCaps().maxTextureSize,m=Math.ceil(n/I);for(let y=0;y<b;y++){const _=new Uint8Array(m*I*4*4);P.push(_)}for(let y=0;y<n;y++)for(let _=0;_<h;_++){const R=e[A++],T=Math.floor(_/16),W=P[T],G=_%16,j=y*16;W[G+j]=R}return new Promise(y=>{y({mode:0,data:s,hasVertexColors:!1,sh:P})})}return new Promise(t=>{t({mode:0,data:s,hasVertexColors:!1})})}_parse(a,r,e,c){const n=[],f=new ReadableStream({start(l){l.enqueue(new Uint8Array(e)),l.close()}}),w=new DecompressionStream("gzip"),C=f.pipeThrough(w);return new Promise(l=>{new Response(C).arrayBuffer().then(s=>{this._parseSPZ(s,r).then(o=>{const p=new D("GaussianSplatting",null,r,this._loadingOptions.keepInRam);p._parentContainer=this._assetContainer,n.push(p),p.updateData(o.data,o.sh)}),l(n)}).catch(()=>{M._ConvertPLYToSplat(e).then(async s=>{switch(s.mode){case 0:{const o=new D("GaussianSplatting",null,r,this._loadingOptions.keepInRam);o._parentContainer=this._assetContainer,n.push(o),o.updateData(s.data)}break;case 1:{const o=new F("PointCloud",1,r);M._BuildPointCloud(o,s.data)?await o.buildMeshAsync().then(p=>{n.push(p)}):o.dispose()}break;case 2:if(s.faces)n.push(M._BuildMesh(r,s));else throw new Error("PLY mesh doesn't contain face informations.");break;default:throw new Error("Unsupported Splat mode")}l(n)})})})}loadAssetContainerAsync(a,r,e){const c=new H(a);return this._assetContainer=c,this.importMeshAsync(null,a,r,e).then(n=>(n.meshes.forEach(f=>c.meshes.push(f)),this._assetContainer=null,c)).catch(n=>{throw this._assetContainer=null,n})}loadAsync(a,r,e){return this.importMeshAsync(null,a,r,e).then(()=>{})}static _ConvertPLYToSplat(a){const r=new Uint8Array(a),e=new TextDecoder().decode(r.slice(0,1024*10)),c=`end_header
`,n=e.indexOf(c);if(n<0||!e)return new Promise(u=>{u({mode:0,data:a})});const f=parseInt(/element vertex (\d+)\n/.exec(e)[1]),w=/element face (\d+)\n/.exec(e);let C=0;w&&(C=parseInt(w[1]));const l=/element chunk (\d+)\n/.exec(e);let s=0;l&&(s=parseInt(l[1]));let o=0,p=0;const x={double:8,int:4,uint:4,float:4,short:2,ushort:2,uchar:1,list:0};let g;(function(u){u[u.Vertex=0]="Vertex",u[u.Chunk=1]="Chunk"})(g||(g={}));let i=1;const k=[],U=e.slice(0,n).split(`
`);for(const u of U)if(u.startsWith("property ")){const[,d,V]=u.split(" ");i==1?p+=x[d]:i==0&&(k.push({name:V,type:d,offset:o}),o+=x[d]),x[d]||Z.Warn(`Unsupported property type: ${d}.`)}else if(u.startsWith("element ")){const[,d]=u.split(" ");d=="chunk"?i=1:d=="vertex"&&(i=0)}const B=o,v=p;return D.ConvertPLYWithSHToSplatAsync(a).then(u=>{const d=new DataView(a,n+c.length);let V=v*s+B*f;const t=[];if(C)for(let m=0;m<C;m++){const y=d.getUint8(V);if(y==3){V+=1;for(let _=0;_<y;_++){const R=d.getUint32(V+(2-_)*4,!0);t.push(R)}V+=12}}if(s)return new Promise(m=>{m({mode:0,data:u.buffer,sh:u.sh,faces:t,hasVertexColors:!1})});let h=0,b=0;const A=["x","y","z","scale_0","scale_1","scale_2","opacity","rot_0","rot_1","rot_2","rot_3"],P=["red","green","blue","f_dc_0","f_dc_1","f_dc_2"];for(let m=0;m<k.length;m++){const y=k[m];A.includes(y.name)&&h++,P.includes(y.name)&&b++}const O=h==A.length&&b==3,I=C?2:O?0:1;return new Promise(m=>{m({mode:I,data:u.buffer,sh:u.sh,faces:t,hasVertexColors:!!b})})})}}M._DefaultLoadingOptions={keepInRam:!1,flipY:!1};K(new M);export{M as SPLATFileLoader};
