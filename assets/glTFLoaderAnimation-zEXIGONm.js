import{q as m,b as h,Q as p}from"./index-UsGQmXg2.js";function A(i,n,t,e){return h.FromArray(n,t).scaleInPlace(e)}function f(i,n,t,e){return p.FromArray(n,t).scaleInPlace(e)}function b(i,n,t,e){const o=new Array(i._numMorphTargets);for(let r=0;r<o.length;r++)o[r]=n[t++]*e;return o}class c{constructor(n,t,e,o){this.type=n,this.name=t,this.getValue=e,this.getStride=o}_buildAnimation(n,t,e){const o=new m(n,this.name,t,this.type);return o.setKeys(e),o}}class l extends c{buildAnimations(n,t,e,o,r){r(n._babylonTransformNode,this._buildAnimation(t,e,o))}}class _ extends c{buildAnimations(n,t,e,o,r){if(n._numMorphTargets)for(let s=0;s<n._numMorphTargets;s++){const u=new m(`${t}_${s}`,this.name,e,this.type);if(u.setKeys(o.map(a=>({frame:a.frame,inTangent:a.inTangent?a.inTangent[s]:void 0,value:a.value[s],outTangent:a.outTangent?a.outTangent[s]:void 0,interpolation:a.interpolation}))),n._primitiveBabylonMeshes){for(const a of n._primitiveBabylonMeshes)if(a.morphTargetManager){const T=a.morphTargetManager.getTarget(s),g=u.clone();T.animations.push(g),r(T,g)}}}}}const I={translation:[new l(m.ANIMATIONTYPE_VECTOR3,"position",A,()=>3)],rotation:[new l(m.ANIMATIONTYPE_QUATERNION,"rotationQuaternion",f,()=>4)],scale:[new l(m.ANIMATIONTYPE_VECTOR3,"scaling",A,()=>3)],weights:[new _(m.ANIMATIONTYPE_FLOAT,"influence",b,i=>i._numMorphTargets)]};export{c as A,I as n};
