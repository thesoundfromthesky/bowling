import{G as S,A as _}from"./glTFLoader-2qMQejKH.js";import{M as k,u as C,r as I}from"./index-UsGQmXg2.js";import"./glTFLoaderAnimation-zEXIGONm.js";const n="KHR_materials_variants";class i{constructor(t){this.name=n,this._loader=t,this.enabled=this._loader.isExtensionUsed(n)}dispose(){this._loader=null}static GetAvailableVariants(t){const e=this._GetExtensionMetadata(t);return e?Object.keys(e.variants):[]}getAvailableVariants(t){return i.GetAvailableVariants(t)}static SelectVariant(t,e){const s=this._GetExtensionMetadata(t);if(!s)throw new Error(`Cannot select variant on a glTF mesh that does not have the ${n} extension`);const o=h=>{const f=s.variants[h];if(f)for(const m of f)m.mesh.material=m.material};if(e instanceof Array)for(const h of e)o(h);else o(e);s.lastSelected=e}selectVariant(t,e){i.SelectVariant(t,e)}static Reset(t){const e=this._GetExtensionMetadata(t);if(!e)throw new Error(`Cannot reset on a glTF mesh that does not have the ${n} extension`);for(const s of e.original)s.mesh.material=s.material;e.lastSelected=null}reset(t){i.Reset(t)}static GetLastSelectedVariant(t){const e=this._GetExtensionMetadata(t);if(!e)throw new Error(`Cannot get the last selected variant on a glTF mesh that does not have the ${n} extension`);return e.lastSelected}getLastSelectedVariant(t){return i.GetLastSelectedVariant(t)}static _GetExtensionMetadata(t){var e,s;return((s=(e=t==null?void 0:t._internalMetadata)==null?void 0:e.gltf)==null?void 0:s[n])||null}onLoading(){const t=this._loader.gltf.extensions;if(t&&t[this.name]){const e=t[this.name];this._variants=e.variants}}onReady(){var e,s;const t=this._loader.rootBabylonMesh;t&&((s=(e=this._loader.parent.extensionOptions[n])==null?void 0:e.onLoaded)==null||s.call(e,{get variants(){return i.GetAvailableVariants(t)},get selectedVariant(){const o=i.GetLastSelectedVariant(t);return o?Array.isArray(o)?o[0]:o:i.GetAvailableVariants(t)[0]},set selectedVariant(o){i.SelectVariant(t,o)}}))}_loadMeshPrimitiveAsync(t,e,s,o,h,f){return S.LoadExtensionAsync(t,h,this.name,(m,V)=>{const x=new Array;return x.push(this._loader._loadMeshPrimitiveAsync(t,e,s,o,h,l=>{if(f(l),l instanceof k){const $=S._GetDrawMode(t,h.mode),c=this._loader.rootBabylonMesh,A=c?c._internalMetadata=c._internalMetadata||{}:{},E=A.gltf=A.gltf||{},g=E[n]=E[n]||{lastSelected:null,original:[],variants:{}};g.original.push({mesh:l,material:l.material});for(let u=0;u<V.mappings.length;++u){const M=V.mappings[u],F=_.Get(`${m}/mappings/${u}/material`,this._loader.gltf.materials,M.material);x.push(this._loader._loadMaterialAsync(`#/materials/${M.material}`,F,l,$,T=>{for(let v=0;v<M.variants.length;++v){const w=M.variants[v],p=_.Get(`/extensions/${n}/variants/${w}`,this._variants,w);g.variants[p.name]=g.variants[p.name]||[],g.variants[p.name].push({mesh:l,material:T}),l.onClonedObservable.add(O=>{const G=O;let d=null,r=G;do{if(r=r.parent,!r)return;d=i._GetExtensionMetadata(r)}while(d===null);if(c&&d===i._GetExtensionMetadata(c)){r._internalMetadata={};for(const a in c._internalMetadata)r._internalMetadata[a]=c._internalMetadata[a];r._internalMetadata.gltf=[];for(const a in c._internalMetadata.gltf)r._internalMetadata.gltf[a]=c._internalMetadata.gltf[a];r._internalMetadata.gltf[n]={lastSelected:null,original:[],variants:{}};for(const a of d.original)r._internalMetadata.gltf[n].original.push({mesh:a.mesh,material:a.material});for(const a in d.variants)if(Object.prototype.hasOwnProperty.call(d.variants,a)){r._internalMetadata.gltf[n].variants[a]=[];for(const y of d.variants[a])r._internalMetadata.gltf[n].variants[a].push({mesh:y.mesh,material:y.material})}d=r._internalMetadata.gltf[n]}for(const a of d.original)a.mesh===l&&(a.mesh=G);for(const a of d.variants[p.name])a.mesh===l&&(a.mesh=G)})}}))}}})),Promise.all(x).then(([l])=>l)})}}C(n);I(n,!0,L=>new i(L));export{i as KHR_materials_variants};
